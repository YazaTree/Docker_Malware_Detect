# v0.4
# 동적분석 진행 전 패키지 업데이트 과정 제거
# net-tools 설치 과정에서 apt, apk 판별 진행

import subprocess
import re
import requests
import json
import pandas as pd
import hashlib
import os

docker_img = 'vibersastra/ubuntu'

vt_api_keys = {
    '28d9a6cd45b64bee4d16d74998ea3616275926acfcdee37775433286ec511463':0,
    'f7e3d6f920b7b4fca023e220bf3efc6d2cdbb2b282b2c16bc044f31f51276f68':0,
    '726fc30f54ca2482645013e46a9e539ae1457b0d27a99c2eb4c74ff4b208d788':0
}

def root_check(container_id):
    root_check = subprocess.check_output("sudo docker exec %s whoami" % container_id, shell=True).decode().strip()
    if root_check == 'root':
        print('기본 shell이 root입니다')
    else:
        print('기본 shell이 root가 아닙니다.')

def netstat(container_id):
    try:
        res = subprocess.check_output("sudo docker exec %s apt install net-tools -y" % container_id, shell=True).decode().strip()
        check = 'bash'
    except:
        subprocess.call("sudo docker exec %s apk add net-tools" % container_id, shell=True)
        check = 'sh'

    subprocess.call("sudo docker exec %s netstat -an > ./netstat.txt" % container_id, shell=True)
    ip_addr = []
    with open('./netstat.txt', 'r') as f:
        while True:
            line = f.readline()
            word = line.split()
            for item in word:
                try:
                    m = re.match(r"(?P<IP>[0-9.]+):", item)
                    ip_addr.append(m.group())
                except: pass
            if not line: break
    if len(ip_addr) == 0:
        print('netstat 미탐지')
    else: 
        for n, ip in enumerate(ip_addr):
            if ':' in ip:
                ip_addr[n] = ip.strip(':')
        foreign_ip = ip_addr[1::2]
        new_ip_addr = []
        for value in foreign_ip:
            if value not in new_ip_addr:
                new_ip_addr.append(value)

        print(new_ip_addr)

        url = 'https://www.virustotal.com/vtapi/v2/url/scan'
        url_report = 'https://www.virustotal.com/vtapi/v2/url/report'
        for ip in new_ip_addr:
            if ip == '0.0.0.0' or ip == '127.0.0.1':
                pass
            else:
                apikey = min(vt_api_keys, key=vt_api_keys.get)  # 카운트가 가장 적은 키 호출
                print("%s 검사 시작" % ip)
                #print("%s 사용하는 key" % apikey)
                params = {'apikey':apikey,'url': ip}
                response_scan = requests.post(url, data=params)
                result_scan = response_scan.json()
                vt_api_keys[apikey] += 1
                scan_id = result_scan['scan_id']

                try:
                    apikey = min(vt_api_keys, key=vt_api_keys.get)
                    vt_api_keys[apikey] += 1
                    url_report_params = {'apikey': apikey, 'resource': scan_id}
                    response_report = requests.get(url_report, params=url_report_params)
                except:
                    apikey = min(vt_api_keys, key=vt_api_keys.get)
                    vt_api_keys[apikey] += 1
                    time.sleep(15)
                    url_report_params = {'apikey': apikey, 'resource': scan_id}
                    response_report = requests.get(url_report, params=url_report_params)

                report = response_report.json()
                number = 0
                for x in report['scans']:
                    if report['scans'][x]['detected']:
                        number = number + 1
                        print("{0:22} : {1}".format(x,report['scans'][x]['result']))
                print("{0} engines detected this file".format(number))
                print('\n')

    os.remove('./netstat.txt')
    return check

def lsof(container_id, check):
    if check == 'sh':
        subprocess.call("sudo docker exec %s apk add lsof" % container_id, shell=True)
    else:
        subprocess.call("sudo docker exec %s apt install lsof -y" % container_id, shell=True)
    subprocess.call("sudo docker exec %s lsof -i 4 > ./lsof.txt" % container_id, shell=True)
    size = os.path.getsize('./lsof.txt')
    if (size==0):
        subprocess.call("sudo docker exec %s lsof -i TCP > ./lsof.txt" % container_id, shell=True)
        size = os.path.getsize('./lsof.txt')
        if (size==0):
            print("lsof 미탐지")
        else:
            print("lsof 탐지")
            with open('./lsof.txt', 'r') as f:
                data = f.readlines()
            column_name = data[0].strip().split()
            column_name.append('STATE')
            data_split = [x.strip().split() for x in data[1:]]
            print(data_split)
    else:
        print("lsof 탐지")
        with open('./lsof.txt', 'r') as f:
            data = f.readlines()
        column_name = data[0].strip().split()
        column_name.append('STATE')
        data_split = [x.strip().split() for x in data[1:]]
        print(data_split)
    os.remove('./lsof.txt')


def detect_executable_file(container_id):
    subprocess.call("sudo docker history --no-trunc %s > ./history.txt" % docker_img, shell=True)
    find_workdir = 'WORKDIR'
    find_word = 'ENTRYPOINT'
    execu_f_list = []
    with open('./history.txt', 'r') as f:
        data = f.read()
        data_list = data.split()
    for word in data_list:
        if word == find_workdir:
            workdir = data_list[data_list.index(word) + 1]
        if word == find_word:
            execu_f = data_list[data_list.index(word) + 1]
            execu_f = re.sub('\[|\]|"', "", execu_f)
            execu_f_list.append(execu_f)
            del data_list[data_list.index(word)]  # ENTRYPOINT 명령이 중복되지 않도록 제거
                
    for execu_f in execu_f_list:
        if './' in execu_f:
            execu_f = execu_f.replace('./', '/')
            execu_f = workdir + execu_f
        original_execu = os.path.basename(execu_f)  # 전체 파일 경로에서 파일 이름만 추출 ex: /bin/minerd => minerd
        
        if not 'entrypoint' in execu_f :
            print("컨테이너가 실행될 때 다음 프로세스가 자동 실행됩니다. : %s" % original_execu)
            subprocess.call("sudo docker cp %s:%s %s" % (container_id, execu_f, './'), shell=True)  # 현재 경로로 실행 파일 복사
            url_scan = 'https://www.virustotal.com/vtapi/v2/file/scan'
            url_report = 'https://www.virustotal.com/vtapi/v2/file/report'
            f = open(original_execu, 'rb')
            data = f.read()
            f.close()
            f_md5 = hashlib.md5(data).hexdigest()
            apikey = min(vt_api_keys, key=vt_api_keys.get)
            #print("%s 사용하는 key" % apikey)
            params = {'apikey': apikey, 'resource':f_md5}
            try:
                response = requests.get(url_report, params=params)
                result = response.json()
                vt_api_keys[apikey] += 1
            except:
                apikey = min(vt_api_keys, key=vt_api_keys.get)
                #print("%s 사용하는 key" % apikey)
                params = {'apikey': apikey}
                files = {'file':(original_execu, open(original_execu, 'rb'))}
                response = requests.post(url_scan, files=files, params=params)
                time.sleep(15)
                response = requests.get(url_report, params=params)
                result = response.json()
                vt_api_keys[apikey] += 1
            det = 0

            detected_engines = []  # 감지된 엔진을 저장할 리스트
            
            for x in result['scans']:
                if result['scans'][x]['detected']:
                    det += 1
                    detection_result = "{0:22} : {1}".format(x, result['scans'][x]['result'])
                    detected_engines.append(detection_result)

            detected_engines_count = len(detected_engines)

            # 변수로 저장된 결과 출력
            for detection in detected_engines:
                print(detection)
            print("{0} engines detected this file".format(detected_engines_count))
    
        os.remove(original_execu)
    os.remove('./history.txt')

def main():
    subprocess.call("sudo docker run -d -t %s" % docker_img, shell=True)
    container_id = subprocess.check_output("sudo docker container ls -q | head -n 1", shell=True).decode().strip()

    root_check(container_id)
    check = netstat(container_id)
    #print(check)
    lsof(container_id, check)
    detect_executable_file(container_id)

if __name__ == "__main__":
    main()
