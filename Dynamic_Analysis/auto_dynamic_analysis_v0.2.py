# v0.2
# root가 아닌 일반 유저에서도 동작할 수 있도록 보완

import subprocess
import re
import requests
import json
import pandas as pd
import hashlib
import os

docker_img = 'ynprpagamentitk/liferay'

def root_check(container_id):
    root_check = subprocess.check_output("sudo docker exec %s whoami" % container_id, shell=True).decode().strip()
    if root_check == 'root':
        print('기본 shell이 root입니다')
    else:
        print('기본 shell이 root가 아닙니다.')

def netstat(container_id, check):
    if check == 'sh':
        subprocess.call("sudo docker exec %s apk add net-tools" % container_id, shell=True)
    else:
        subprocess.call("sudo docker exec %s apt install net-tools -y" % container_id, shell=True)
        
    subprocess.call("sudo docker exec %s netstat -an > ./netstat.txt" % container_id, shell=True)
    ip_addr = []
    with open('./netstat.txt', 'r') as f:
        while True:
            line = f.readline()
            word = line.split()
            for item in word:
                try:
                    m = re.match(r"(?P<IP>[0-9.]+):", item)
                    ip_addr.append(m.group())
                except: pass
            if not line: break
    if len(ip_addr) == 0:
        print('netstat 미탐지')
    else: 
        for n, ip in enumerate(ip_addr):
            if ':' in ip:
                ip_addr[n] = ip.strip(':')
        foreign_ip = ip_addr[1::2]
        new_ip_addr = []
        for value in foreign_ip:
            if value not in new_ip_addr:
                new_ip_addr.append(value)

        print(new_ip_addr)

        apikey = '28d9a6cd45b64bee4d16d74998ea3616275926acfcdee37775433286ec511463'
        url = 'https://www.virustotal.com/vtapi/v2/url/scan'
        url_report = 'https://www.virustotal.com/vtapi/v2/url/report'
        for ip in new_ip_addr:
            if ip == '0.0.0.0' or ip == '127.0.0.1':
                pass
            else:
                print("%s 검사 시작" % ip)
                params = {'apikey':apikey,'url': ip}
                response_scan = requests.post(url, data=params)
                result_scan = response_scan.json()
                scan_id = result_scan['scan_id']
                url_report_params = {'apikey': apikey, 'resource': scan_id}
                response_report = requests.get(url_report, params=url_report_params)
                report = response_report.json()
                number = 0
                for x in report['scans']:
                    if report['scans'][x]['detected']:
                        number = number + 1
                        print("{0:22} : {1}".format(x,report['scans'][x]['result']))
                print("{0} engines detected this file".format(number))
                print('\n')

    os.remove('./netstat.txt')

def lsof(container_id, check):
    if check == 'sh':
        subprocess.call("sudo docker exec %s apk add lsof" % container_id, shell=True)
    else:
        subprocess.call("sudo docker exec %s apt install lsof -y" % container_id, shell=True)
    subprocess.call("sudo docker exec %s lsof -i 4 > ./lsof.txt" % container_id, shell=True)
    size = os.path.getsize('./lsof.txt')
    if (size==0):
        subprocess.call("sudo docker exec %s lsof -i TCP > ./lsof.txt" % container_id, shell=True)
        if (size==0):
            print("lsof 미탐지")
        else:
            print("lsof 탐지")
            with open('./lsof.txt', 'r') as f:
                data = f.readlines()
    else:
        print("lsof 탐지")
        with open('./lsof.txt', 'r') as f:
            data = f.readlines()
        column_name = data[0].strip().split()
        column_name.append('STATE')
        data_split = [x.strip().split() for x in data[1:]]
        print(data_split)
        #df = pd.DataFrame(data_split, columns = column_name)
        #row_len = len(df)
        #for row in range(row_len):
        #    print(df.iloc[row]['COMMAND'])
        #    print(df.iloc[row]['NAME'])
        #    print(df.iloc[row]['STATE'])

    os.remove('./lsof.txt')


def detect_executable_file(container_id):
    subprocess.call("sudo docker history --no-trunc %s > ./history.txt" % docker_img, shell=True)
    find_workdir = 'WORKDIR'
    find_word = 'ENTRYPOINT'
    execu_f_list = []
    with open('./history.txt', 'r') as f:
        data = f.read()
        data_list = data.split()
    for word in data_list:
        if word == find_workdir:
            workdir = data_list[data_list.index(word) + 1]
        if word == find_word:
            execu_f = data_list[data_list.index(word) + 1]
            execu_f = re.sub('\[|\]|"', "", execu_f)
            execu_f_list.append(execu_f)
            del data_list[data_list.index(word)]  # ENTRYPOINT 명령이 중복되지 않도록 제거
                
    for execu_f in execu_f_list:
        if './' in execu_f:
            execu_f = execu_f.replace('./', '/')
            execu_f = workdir + execu_f
        original_execu = os.path.basename(execu_f)  # 전체 파일 경로에서 파일 이름만 추출 ex: /bin/minerd => minerd
            
        print("컨테이너가 실행될 때 다음 프로세스가 자동 실행됩니다. : %s" % original_execu)
        if not 'docker-entrypoint.sh' in execu_f :
            subprocess.call("sudo docker cp %s:%s %s" % (container_id, execu_f, './'), shell=True)  # 현재 경로로 실행 파일 복사
            apikey = 'f7e3d6f920b7b4fca023e220bf3efc6d2cdbb2b282b2c16bc044f31f51276f68'
            url_scan = 'https://www.virustotal.com/vtapi/v2/file/scan'
            url_report = 'https://www.virustotal.com/vtapi/v2/file/report'
            f = open(original_execu, 'rb')
            data = f.read()
            f.close()
            f_md5 = hashlib.md5(data).hexdigest()
            params = {'apikey': apikey, 'resource':f_md5}
            try:
                response = requests.get(url_report, params=params)
                result = response.json()
            except:
                params = {'apikey': apikey}
                files = {'file':(original_execu, open(original_execu, 'rb'))}
                response = requests.post(url_scan, files=files, params=params)
                time.sleep(30)
                response = requests.get(url_report, params=params)
                result = response.json()
            det = 0
            for x in result['scans']:
                if result['scans'][x]['detected']:
                    det = det + 1
                    print("{0:22} : {1}".format(x,result['scans'][x]['result']))
            print("{0} engines detected this file".format(det))
            print(original_execu)

    os.remove(original_execu)
    os.remove('./history.txt')

def main():
    subprocess.call("sudo docker run -d -t %s" % docker_img, shell=True)
    container_id = subprocess.check_output("sudo docker container ls -q | head -n 1", shell=True).decode().strip()
    
    try:
        res = subprocess.check_output("sudo docker exec %s apt update" % container_id, shell=True).decode().strip()
        check = 'bash'
    except:
        subprocess.call("sudo docker exec %s apk update" % container_id, shell=True)
        check = 'sh'
    print(check)

    root_check(container_id)
    netstat(container_id, check)
    lsof(container_id, check)
    detect_executable_file(container_id)

if __name__ == "__main__":
    main()
