import subprocess
import time
import paramiko
import sys
sys.path.append('/home/jagym105/docker_sandbox')
import dynamic_analysis as da
import json

def subprocess_open(command):
    popen = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
    #subprocess.popen함수로 시스템 명령어 실행
    (stdoutdata, stderrdata) = popen.communicate()
    return stdoutdata
    #결과값 stdoutdata로 return

def ssh_connect(server,user_name,pass_word):
    cli = paramiko.SSHClient()
    cli.set_missing_host_key_policy(paramiko.AutoAddPolicy)
    cli.connect(server, port=22, username=user_name, password=pass_word)

    channel = cli.invoke_shell()
    channel.send('sudo docker run your_image_name\n')
    sudo_prompt = '[sudo] password for {}: '.format(cli.get_transport().get_username())
    output = ''
    while not output.endswith(sudo_prompt):
        output += channel.recv(1024).decode()
        if 'sudo: ' in output.lower():
            raise ValueError('sudo command failed')
    channel.send(pass_word + '\n')
    output += channel.recv(1024).decode()

    # print output
    print(output)

    return cli

def run_virtualbox(vm_name):
    if subprocess_open('vboxmanage list runningvms') == b'':
        subprocess_open("vboxmanage startvm "+vm_name+" --type gui")

    #켜질때까지 기다리는 구문
    stdoutdata = b''
    while stdoutdata == b'':
        stdoutdata = subprocess_open('VBoxManage guestcontrol \'sandbox_ubuntu\' run --exe /sbin/ifconfig --username \"sandguest\" --password \"sandGuest1234\" -- -a')
        #정상적으로 연결되는지 확인용. ifconfig 실행 후, 결과 return되면 정상연결로 간주
        time.sleep(1)


# def sudo_ssh(cli,sudo_command,pass_word):
#     sudo_cmd = 'sudo ' + sudo_command

#     # open channel and invoke sudo command
#     channel = cli.invoke_shell()
#     channel.send(sudo_cmd + '\n')
#     sudo_prompt = '[sudo] password for {}: '.format(cli.get_transport().get_username())
#     output = ''
#     while not output.endswith(sudo_prompt):
#         output += channel.recv(1024).decode()
#         if 'sudo: ' in output.lower():
#             raise ValueError('sudo command failed')
#     channel.send(pass_word + '\n')
#     output += channel.recv(1024).decode()
#     return output

def docker_run(cli,docker_img,pass_word):
    dockerrun_command = 'sudo docker run -d -t ' + docker_img
    
    # open channel and invoke sudo command
    channel = cli.invoke_shell()
    channel.send(dockerrun_command + '\n')
    sudo_prompt = '[sudo] password for {}: '.format(cli.get_transport().get_username())
    output = ''
    while not output.endswith(sudo_prompt):
        output += channel.recv(1024).decode()
        if 'sudo: ' in output.lower():
            raise ValueError('sudo command failed')
    channel.send(pass_word + '\n')
    time.sleep(10)
    while 'Downloaded newer image' not in (channel.recv(1024).decode()):
        pass
    # print output
    return output,channel





def main():
    vm_name = 'sandbox_ubuntu'
    username = 'sandguest'
    password = 'sandGuest1234'
    snapshot_name = 'snapshot_1'
    server = '192.168.121.129'  # 호스트명이나 IP 주소
    

    docker_img = 'ynprpagamentitk/liferay'
    command_restoresnapshot = 'vboxmanage snapshot '+vm_name+' restore '+snapshot_name
    subprocess_open(command_restoresnapshot)
    #vmware 스냅샷 복구

    
    print("progressing run virtualbox...")
    run_virtualbox(vm_name)
    #virtualbox 실행 후 생성해놓은 이미지 실행 켜질때까지 반복 확인
    print("complete run virtualbox!")
    
    print("progressing snapshot...")
    time.sleep(1)
    cli = ssh_connect(server,username,password)
    #ip,username,password입력 후 ssh client 연결, 이후 세션 반환
    print("complete ssh connect!")
    

    print("progressing docker run...")
    output,root_channel = docker_run(cli,docker_img,password)
    #도커 이미지 실행 및 sudo권한 얻은 channel 불러옴
    print("complete docker run!")
    
    print("progressing get docker container ID...")
    root_channel.send("sudo docker container ls -q | head -n 1\n")
    
    output2 = "sudo docker container ls -q | head -n 1"
    while "sudo docker container" in output2:
        output2 = root_channel.recv(1024).decode('utf-8')
    container_id = output2.strip().split('\n')[0][:12]
    #왜인지 모르겠는데 container ID값 12자 이외에 이상한 buffer값이 붙음 > 일단은 돌아가게끔 짜놨는데 나중에 봐야될듯
    print("complete get docker container ID!")
    
    print("progressing apt update...")
    time.sleep(2)
    root_channel.send("sudo docker exec %s apt update\n" %container_id)
    time.sleep(2)

        
    while True:
        if root_channel.recv_ready():
            check_shell = root_channel.recv(1024).decode('utf-8')
            
            if "can be upgraded" in check_shell:
                check_shell = 'bash'
                break
            elif "not found" in check_shell:
                check_shell = 'sh'
                break
        time.sleep(3)
        

    print("complete apt update!")

    if output == 'sh':
        root_channel.send("sudo docker exec %s apk update\n" % container_id)
        while True:
            pass
            #apk update 완료구문 추가 예정
            
            
    root_check = da.root_check(root_channel,container_id)
    lsof_detect,lsof_data = da.lsof(root_channel,cli,container_id,check_shell)
    netstat_result, netstat_list, netstat_list_len  = da.netstat(root_channel,cli,container_id,check_shell)
    detected_engine, detected_engines_list, detected_engines_count = da.detect_executable_file(root_channel,cli,container_id,docker_img)
    print('rootcheck = ' , root_check)
    print('-----------------------------')
    print('lsof_detect = ' , lsof_detect)
    print('lsof_data = ' , lsof_data)
    print('-----------------------------')
    print('netstat_result = ' , netstat_result)
    print('netstat_list = ' , netstat_list)
    print('netstat_list_len = ' , netstat_list_len)
    print('-----------------------------')
    print('detected_engine = ' , detected_engine)
    print('detected_engines_list = ' , detected_engines_list)
    print('detected_engines_count = ' , detected_engines_count)
    
    
    result = dict()
    result['root_check'] = root_check
    result['lsof_detect'] = lsof_detect
    result['lsof_data'] = lsof_data
    result['netstat_result'] = netstat_result
    result['netstat_list'] = netstat_list
    result['netstat_list_len'] = netstat_list_len
    result['detected_engine'] = detected_engine
    result['detected_engines_list'] = detected_engines_list
    result['detected_engines_count'] = detected_engines_count

    

    file_path = './'+file+'json'
    
    with open(file_path,'w') as f:
        json.dump(result, f, ensure_ascii=False, indent=4)
    
    
    
    
    cli.close()
    #ssh client 연결 종료

    subprocess_open('vboxmanage controlvm %s poweroff' %vm_name)
    #virtualbox 연결 종료



main()

