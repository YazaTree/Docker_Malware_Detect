import subprocess
import re
import requests
import json
import pandas as pd
import hashlib
import os
import time

vt_api_keys = {
    '':0,
    '':0,
    '':0,
    '':0,
    '':0
}


def root_check(root_channel,container_id):
    root_channel.send("sudo docker exec %s whoami\n" % container_id)
    time.sleep(2)
    output = root_channel.recv(10240).decode('utf-8')

    if 'root' in output:
        return 1
    else :
        return 0

def netstat(root_channel,cli,container_id, check):
    if check == 'apk':
        time.sleep(1)
        root_channel.send("sudo docker exec %s apk add net-tools\n" %container_id)
    elif check == 'apt':
        time.sleep(1)
        root_channel.send("sudo docker exec %s apt install net-tools -y\n" %container_id)
    elif check == 'yum':
        time.sleep(1)
        root_channel.send("sudo docker exec %s yum install net-tools -y\n" %container_id)
    time.sleep(3)
    output = root_channel.recv(1024).decode('utf-8')
    print(output)
    while True:
        if 'Setting up net-tools' in output:
            break
        elif 'OK' in output:
            break
        elif 'Complete!' in output:
            break
        time.sleep(1)
        if root_channel.recv_ready():
            output = root_channel.recv(1024).decode('utf-8')

    #net-tools 다운 완료됐다는 확인이 필요함
    time.sleep(1)
    root_channel.send("sudo docker exec %s netstat -an > ./netstat.txt\n" % container_id)
    time.sleep(1)
 
    ip_addr = []
    with cli.open_sftp().open('netstat.txt') as f:
        while True:
            line = f.readline()
            word = line.split()
            for item in word:
                try:
                    m = re.match(r"(?P<IP>[0-9.]+):", item)
                    ip_addr.append(m.group())
                except: pass
            if not line: break
    if len(ip_addr) == 0:
        netstat_result = 0
        netstat_dict = {}
    else:
        netstat_result = 1
        for n, ip in enumerate(ip_addr):
            if ':' in ip:
                ip_addr[n] = ip.strip(':')
        foreign_ip = ip_addr[1::2]
        new_ip_addr = []
        for value in foreign_ip:
            if value not in new_ip_addr:
                new_ip_addr.append(value)

        print(new_ip_addr)
        url = 'https://www.virustotal.com/vtapi/v2/url/scan'
        url_report = 'https://www.virustotal.com/vtapi/v2/url/report'
        netstat_dict = {}
        for ip in new_ip_addr:
            if ip == '0.0.0.0' or ip == '127.0.0.1':
                pass
            else:
                netstat_value = []
                apikey = min(vt_api_keys, key=vt_api_keys.get)  # 카운트가 가장 적은 키 호출
                print("%s 검사 시작" % ip)
                params = {'apikey':apikey,'url': ip}
                response_scan = requests.post(url, data=params)
                result_scan = response_scan.json()
                vt_api_keys[apikey] += 1
                scan_id = result_scan['scan_id']
                
                try:
                    apikey = min(vt_api_keys, key=vt_api_keys.get)
                    vt_api_keys[apikey] += 1
                    url_report_params = {'apikey': apikey, 'resource': scan_id}
                    response_report = requests.get(url_report, params=url_report_params)
                except:
                    apikey = min(vt_api_keys, key=vt_api_keys.get)
                    vt_api_keys[apikey] += 1
                    time.sleep(15)
                    url_report_params = {'apikey': apikey, 'resource': scan_id}
                    response_report = requests.get(url_report, params=url_report_params)

                report = response_report.json()
                number = 0
                for x in report['scans']:
                    if report['scans'][x]['detected']:
                        number = number + 1
                        netstat_value.append("{0:22} : {1}".format(x,report['scans'][x]['result']))
                netstat_value_len = len(netstat_value)
                netstat_value.append(netstat_value_len)
                netstat_dict[ip] = netstat_value
                
    return netstat_result, len(netstat_dict), netstat_dict

def lsof(root_channel,cli,container_id, check):
    if check == 'apk':
        time.sleep(1)
        root_channel.send("sudo docker exec %s apk add lsof\n" %container_id)
        time.sleep(1)
    elif check == 'apt':
        time.sleep(1)
        root_channel.send("sudo docker exec %s apt install lsof -y\n" % container_id)
        time.sleep(1)
    elif check == 'yum':
        time.sleep(1)
        root_channel.send("sudo docker exec %s yum install lsof -y\n" % container_id)
        time.sleep(1)
        
    output = root_channel.recv(1024).decode('utf-8')
    print(output)
    while True:
        if 'Setting up lsof' in output:
            break
        elif 'OK' in output:
            break
        elif 'Complete!' in output:
            break
        time.sleep(1)
        if root_channel.recv_ready():
            output = root_channel.recv(1024).decode('utf-8')
            
    time.sleep(1)
    root_channel.send("sudo docker exec %s lsof -i 4 > lsof.txt\n" % container_id)
    time.sleep(6)
    file_path = 'lsof.txt'
    sftp = cli.open_sftp()
    attr = sftp.stat(file_path)
    size = attr.st_size
    #change
    if (size==0):
        time.sleep(1)
        root_channel.send("sudo docker exec %s lsof -i TCP > lsof.txt\n" % container_id)
        time.sleep(1)
        size = attr.st_size
        
        if (size==0):
            lsof_detect = 0
            data_split = 0
            print("lsof 미탐지")
        else:
            lsof_detect = 1
            print("lsof 탐지")
            with cli.open_sftp().open('lsof.txt') as f:
                data = f.readlines()
            column_name = data[0].strip().split()
            column_name.append('STATE')
            data_split = [x.strip().split() for x in data[1:]]
    else:
        lsof_detect = 1
        with cli.open_sftp().open('lsof.txt') as f:
            data = f.readlines()
        column_name = data[0].strip().split()
        column_name.append('STATE')
        data_split = [x.strip().split() for x in data[1:]]
    return lsof_detect,data_split
        #df = pd.DataFrame(data_split, columns = column_name)
        #row_len = len(df)
        #for row in range(row_len):
        #    print(df.iloc[row]['COMMAND'])
        #    print(df.iloc[row]['NAME'])
        #    print(df.iloc[row]['STATE'])



def detect_executable_file(root_channel,cli,container_id,docker_img):
    detected_f = 0
    time.sleep(2)
    root_channel.send("sudo docker history --no-trunc %s > ./history.txt\n" % docker_img)
    time.sleep(2)
    find_workdir = 'WORKDIR'
    find_word = 'ENTRYPOINT'
    execu_f_list = []
    with cli.open_sftp().open('./history.txt','r') as f:
        data = f.read()
        data_list = data.split()
    for i in range(len(data_list)):
        data_list[i] = data_list[i].decode('utf-8')
    
    for word in data_list:
        if find_workdir in word:
            workdir = data_list[data_list.index(word) + 1]
        if find_word in word:
            execu_f = data_list[data_list.index(word) + 1]
            execu_f = re.sub('\[|\]|"', "", execu_f)
            execu_f_list.append(execu_f)
            del data_list[data_list.index(word)]  # ENTRYPOINT 명령이 중복되지 않도록 제거
    
    detected_dict = {}
    for execu_f in execu_f_list:
        detected_f = 1
        if './' in execu_f:
            execu_f = execu_f.replace('./', '/')
            execu_f = workdir + execu_f
        original_execu = os.path.basename(execu_f)  # 전체 파일 경로에서 파일 이름만 추출 ex: /bin/minerd => minerd
        
        if not 'entrypoint' in execu_f :
            print("컨테이너가 실행될 때 다음 프로세스가 자동 실행됩니다. : %s" % original_execu)
            time.sleep(1)
            root_channel.send("sudo docker cp %s:%s %s\n" % (container_id, execu_f, './'))
            time.sleep(5)
            while 'Successfully copied' not in root_channel.recv(1024).decode('utf-8'):
                time.sleep(1)
            
            
            url_scan = 'https://www.virustotal.com/vtapi/v2/file/scan'
            url_report = 'https://www.virustotal.com/vtapi/v2/file/report'
            with cli.open_sftp().open(original_execu, 'rb') as f:
                data = f.read()

            f_md5 = hashlib.md5(data).hexdigest()
            apikey = min(vt_api_keys, key=vt_api_keys.get)
            params = {'apikey': apikey, 'resource':f_md5}
            try:
                response = requests.get(url_report, params=params)
                result = response.json()
                vt_api_keys[apikey] += 1
            except:
                apikey = min(vt_api_keys, key=vt_api_keys.get)
                params = {'apikey': apikey}
                files = {'file':(original_execu, open(original_execu, 'rb'))}
                response = requests.post(url_scan, files=files, params=params)
                vt_api_keys[apikey] += 1
                time.sleep(15)
                apikey = min(vt_api_keys, key=vt_api_keys.get)
                params = {'apikey': apikey}
                response = requests.get(url_report, params=params)
                vt_api_keys[apikey] += 1
                result = response.json()
            det = 0
            detection_value = []
            for x in result['scans']:
                if result['scans'][x]['detected']:
                    det = det + 1
                    detection_value.append("{0:22} : {1}".format(x, result['scans'][x]['result']))
            detection_value_len = len(detection_value)
            detection_value.append(detection_value_len)
            detected_dict[original_execu] = detection_value
    return detected_f, len(detected_dict), detected_dict
