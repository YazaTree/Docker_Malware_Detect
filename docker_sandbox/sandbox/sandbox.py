import subprocess
import time
import paramiko
import sys
sys.path.append('/home/ubuntu/docker_sandbox/dynamic_analysis')
import dynamic_analysis as da
import json
import re
from pymongo import MongoClient
import datetime
import os


def send_jsonData(filename):
    client = MongoClient('', 27017)
    db = client.dbtest

    with open(filename) as file:
        data = json.load(file)

    db = client['Dockerweb']
    collection = db['dynamic']

    if isinstance(data, list):
        collection.insert_many(data)
    else:
        collection.insert_one(data)
        
    client.close()


def subprocess_open(command):
    popen = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
    #subprocess.popen함수로 시스템 명령어 실행
    (stdoutdata, stderrdata) = popen.communicate()
    return stdoutdata
    #결과값 stdoutdata로 return

def ssh_connect(server,user_name,pass_word):
    cli = paramiko.SSHClient()
    cli.set_missing_host_key_policy(paramiko.AutoAddPolicy)
    cli.connect(server, port=22, username=user_name, password=pass_word)

    channel = cli.invoke_shell()
    channel.send('sudo docker run your_image_name\n')
    sudo_prompt = '[sudo] password for {}: '.format(cli.get_transport().get_username())
    output = ''
    while not output.endswith(sudo_prompt):
        output += channel.recv(1024).decode()
        if 'sudo: ' in output.lower():
            raise ValueError('sudo command failed')
    channel.send(pass_word + '\n')
    output += channel.recv(1024).decode()

    # print output
    print(output)

    return cli

def run_virtualbox(vm_name):
    if subprocess_open('vboxmanage list runningvms') == b'':
        subprocess_open("vboxmanage startvm "+vm_name+" --type gui")

    #켜질때까지 기다리는 구문
    stdoutdata = b''
    while stdoutdata == b'':
        stdoutdata = os.system('VBoxManage guestcontrol \'ubuntu\' run --exe /sbin/ifconfig --username \"ubuntu\" --password \"\" -- -a')
        #정상적으로 연결되는지 확인용. ifconfig 실행 후, 결과 return되면 정상연결로 간주
        time.sleep(1)


# def sudo_ssh(cli,sudo_command,pass_word):
#     sudo_cmd = 'sudo ' + sudo_command

#     # open channel and invoke sudo command
#     channel = cli.invoke_shell()
#     channel.send(sudo_cmd + '\n')
#     sudo_prompt = '[sudo] password for {}: '.format(cli.get_transport().get_username())
#     output = ''
#     while not output.endswith(sudo_prompt):
#         output += channel.recv(1024).decode()
#         if 'sudo: ' in output.lower():
#             raise ValueError('sudo command failed')
#     channel.send(pass_word + '\n')
#     output += channel.recv(1024).decode()
#     return output

def docker_run(cli,docker_img,pass_word):
    dockerrun_command = 'sudo docker run -d -t ' + docker_img
    
    # open channel and invoke sudo command
    channel = cli.invoke_shell()
    channel.send(dockerrun_command + '\n')
    sudo_prompt = '[sudo] password for {}: '.format(cli.get_transport().get_username())
    output = ''
    while not output.endswith(sudo_prompt):
        output += channel.recv(1024).decode()
        if 'sudo: ' in output.lower():
            raise ValueError('sudo command failed')
    channel.send(pass_word + '\n')
    time.sleep(10)
    while 'Downloaded newer image' not in (channel.recv(1024).decode()):
        pass
    # print output
    return output,channel

def run_sandbox(docker_img):
    vm_name = 'ubuntu'
    username = 'ubuntu'
    password = ''
    snapshot_name = 'snapshot_1'
    server = ''  # 호스트명이나 IP 주소
    start_time = time.time()
    str_start_time = datetime.datetime.fromtimestamp(int(start_time)).strftime('%Y-%m-%d %H:%M:%S')

    #docker_img = 'ynprpagamentitk/liferay'
    command_restoresnapshot = 'vboxmanage snapshot '+vm_name+' restore '+snapshot_name
    subprocess_open(command_restoresnapshot)
    #vmware 스냅샷 복구

    
    print("progressing run virtualbox...")
    run_virtualbox(vm_name)
    #virtualbox 실행 후 생성해놓은 이미지 실행 켜질때까지 반복 확인
    print("complete run virtualbox!")
    
    print("progressing snapshot...")
    time.sleep(1)
    cli = ssh_connect(server,username,password)
    #ip,username,password입력 후 ssh client 연결, 이후 세션 반환
    print("complete ssh connect!")
    

    print("progressing docker run...")
    output,root_channel = docker_run(cli,docker_img,password)
    #도커 이미지 실행 및 sudo권한 얻은 channel 불러옴
    print("complete docker run!")
    
    print("progressing get docker container ID...")
    root_channel.send("sudo docker container ls -q | head -n 1\n")
    
    output2 = "sudo docker container ls -q | head -n 1"
    while "sudo docker container" in output2:
        output2 = root_channel.recv(1024).decode('utf-8')
    container_id = output2.strip().split('\n')[0][:12]
    #왜인지 모르겠는데 container ID값 12자 이외에 이상한 buffer값이 붙음 > 일단은 돌아가게끔 짜놨는데 나중에 봐야될듯
    print("complete get docker container ID!")
    
    print("progressing apt update...")
    time.sleep(2)
    root_channel.send("sudo docker exec %s apt update\n" % container_id)
    time.sleep(2)

    while True:
        if root_channel.recv_ready():
            check_shell = root_channel.recv(1024).decode('utf-8')
            print(check_shell)
            
            if "can be upgraded" in check_shell or "All packages are up to date" in check_shell or "E:" in check_shell:
                check = 'apt'
                print("complete apt update!")
                break
            elif "not found" in check_shell:
                check = 'apk'
                break
        time.sleep(3)
        

    #print("complete apt update!")

    if check == 'apk':
        root_channel.send("sudo docker exec %s apk update\n" % container_id)
        while True:
            if root_channel.recv_ready():
                check_shell = root_channel.recv(1024).decode('utf-8')
                if "packages available" in check_shell:
                    print("complete apk update!")
                    break
                elif "not found" in check_shell:
                    check = 'yum'
                    break
            time.sleep(3)
                    
    if check == 'yum':
        root_channel.send("sudo docker exec %s yum update -y\n" % container_id)
        while True:
            if root_channel.recv_ready():
                check_shell = root_channel.recv(1024).decode('utf-8')
                if "Complete!" in check_shell:
                    print("complete yum update!")
                    break
            
    root_check = da.root_check(root_channel,container_id)
    lsof_detect,lsof_data = da.lsof(root_channel,cli,container_id,check)
    netstat_result, netstat_dict_len, netstat_dict = da.netstat(root_channel,cli,container_id,check)
    detected_f, detected_dict_len, detected_dict = da.detect_executable_file(root_channel,cli,container_id,docker_img)
    end_time = time.time()
    str_end_time = datetime.datetime.fromtimestamp(int(end_time)).strftime('%Y-%m-%d %H:%M:%S')

    elapsed_time = end_time - start_time
    
    print('분석 시작시간 = ',str_start_time)
    print('분석 종료시간 = ',str_end_time)
    print('분석 소요시간 = ',elapsed_time)
    print('rootcheck = ' , root_check)
    print('-----------------------------')
    print('lsof_detect = ' , lsof_detect)
    print('lsof_data = ' , lsof_data)
    print('-----------------------------')
    print('netstat_result = ' , netstat_result)
    print('netstat_dict_len = ' , netstat_dict_len)
    print('netstat_dict = ' , netstat_dict)
    print('-----------------------------')
    print('detected_f = ' , detected_f)
    print('detected_dict_len = ' ,  detected_dict_len)
    print('detected_dict = ' , detected_dict)
    
    
    result = dict()
    result['docker_img'] = docker_img
    result['start_time'] = str_start_time
    result['finish_time'] = str_end_time
    result['elapsed_time'] = elapsed_time
    
    result['root_check'] = root_check
    result['lsof_detect'] = lsof_detect
    result['lsof_data'] = lsof_data
    result['netstat_result'] = netstat_result
    result['netstat_dict'] = netstat_dict
    result['netstat_dict_len'] = netstat_dict_len
    result['detected_f'] = detected_f
    result['detected_dict_len'] = detected_dict_len
    result['detected_dict'] = detected_dict
    
    imagename = re.sub('/','_',docker_img)
    #'/'는 파일명에 사용 불가하여, '_'로 변경
    
    file_path = '/home/ubuntu/docker_sandbox/dynamic_analysis/result_json/'+imagename+'.json'
    
    with open(file_path,'w') as f:
        json.dump(result, f, ensure_ascii=False, indent=4)
    #json형태로 저장
        
        
        
    
    send_jsonData(file_path)
    #json파일 db로 전송
    
    
    
    cli.close()
    #ssh client 연결 종료

    subprocess_open('vboxmanage controlvm %s poweroff' %vm_name)
    #virtualbox 연결 종료

#docker_img = 'ynprpagamentitk/liferay'
#run_sandbox(docker_img)
