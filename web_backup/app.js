var createError = require('http-errors');
var express = require('express');
var path = require('path');
//var cookieParser = require('cookie-parser');


var indexRouter = require('./routes/index');
var usersRouter = require('./routes/users');

var app = express();

// view engine setup
app.set('views', path.join(__dirname, 'views'));
app.set('view engine', 'ejs');

// port setup
app.set('port', process.env.PORT || 9099);

// mongoose 설정
//app.use(logger('dev'));
const mongoose = require('mongoose');
const { GridFSBucket } = require('mongodb');
const morgan = require('morgan')

// DB 연결
const test_db = require('./models/test');

mongoose.connect(
  'mongodb://127.0.0.1:27017',
  {
    dbName: "Dockerweb",
    useNewUrlParser: true,
    useUnifiedTopology: true,
  }
)

const db = mongoose.connection
db.on('error', console.error)
db.once('open', () => {
  console.log('Connected to mongodb Server')
})


// const a = db.collection('dynamic').find()
// console.log(a)

app.use(express.json());
app.use(express.urlencoded({ extended: false }));
//app.use(cookieParser());
app.use(express.static(path.join(__dirname, 'public')));


// 검색 요청
app.get('/', indexRouter);
app.post('/', (req, res) => { //이미지명 분석 요청 들어오면
  const imageName = req.body.search_box;

  // 정적 분석 결과 출력
  // static 컬렉션에서 이미지명 조회
  db.collection('static').findOne({ "docker_img": imageName }, (err, data) => {
    if (err) { //에러 발생
      console.error(err);
      res.status(500).json({ error: 'Internal Server Error' });
    } else {
      if (!data) {
        db.collection('docker_img').findOne({ "ImageName": imageName }, (err, data2) => {
          if (err) {
            console.error(err);
            res.status(500).json({ error: 'Internal Server Error' });
          } else {
            if (!data2) {  //분석 리스트에 이미지명이 없으면
              db.collection('docker_img').insertOne({ ImageName: imageName }, (err, result) => {
                if (err) {
                  console.error(err);
                  res.status(500).json({ error: 'Internal Server Error' });
                } else {
                  //저장
                  console.log('저장이 완료되었습니다.');
                  printDatabase(req, res);
                  res.redirect('/fetch-data?search_box=' + encodeURIComponent(imageName));
                }
              });
            } else {
              //분석리스트에 이미지명 존재
              console.log('이미지명이 분석리스트에 존재합니다.');
              // 검색어 db 저장
              db.collection('recent_search').updateOne({ "SearchString": imageName }, { $set: { "createAt": new Date() } }, { upsert: true }, async (err, data3) => {
                if (err) {
                  console.error(err);
                  res.status(500).json({ error: 'Internal Server Error' });
                } else {
                  console.log('recent_search save success');

                  let documentCount = await db.collection('recent_search').countDocuments();

                  while (documentCount > 10) {
                    const oldestDocument = await db.collection('recent_search').findOne({}, { sort: { createAt: 1 } });
                    if (oldestDocument) {
                      await db.collection('recent_search').deleteOne({ _id: oldestDocument._id });
                      documentCount--;
                      console.log('Oldest Document deleted');
                    }
                  }
                }
              });
              printDatabase(req, res);
              res.redirect('/fetch-data?search_box=' + encodeURIComponent(imageName));
            }
          }
        });
      } else {
        console.log('데이터 확인');
        // 검색어 db 저장
        db.collection('recent_search').updateOne({ "SearchString": imageName }, { $set: { "createAt": new Date() } }, { upsert: true }, async (err, data3) => {
          if (err) {
            console.error(err);
            res.status(500).json({ error: 'Internal Server Error' });
          } else {
            console.log('recent_search save success');

            let documentCount = await db.collection('recent_search').countDocuments();

            while (documentCount > 10) {
              const oldestDocument = await db.collection('recent_search').findOne({}, { sort: { createAt: 1 } });
              if (oldestDocument) {
                await db.collection('recent_search').deleteOne({ _id: oldestDocument._id });
                documentCount--;
                console.log('Oldest Document deleted');
              }
            }
          }
        });
        printDatabase(req, res);
        //dy는 어차피 링크를 통해서 확인하기 때문에 따로 함수 호출 필요 x
        return;
      }
    }
  });
});

//서버에 지속적 요청
app.get('/fetch-data', (req, res) => {
  const imageName = req.query.search_box; // 이미지명 추출

  recursivePrintDb(imageName, res); // 재귀적으로 데이터 확인

  function recursivePrintDb(imageName, res, isFirstCall = true) {
    console.log('함수 호출');
    console.log(imageName);
    if (!isFirstCall) {
      setTimeout(() => {
        console.log('데이터 없음');
        console.log(imageName);
        recursivePrintDb(imageName, res, false); // 재귀적으로 호출하여 일정 시간마다 데이터 확인
      }, 10000); // 10초마다 요청
      return;
    }
    db.collection('static').findOne({ docker_img: imageName }, (err, result) => {
      if (err) {
        console.error(err);
        res.status(500).json({ error: 'Internal Server Error' });
      } else {
        if (result) {
          console.log('데이터 확인');
          if (result.start_time === 'error') {
            // start_time 필드가 'error'이면 'non_dockerimg'로 render
            res.render('non_dockerimg');

            // 해당 도커 이미지 데이터 삭제
            db.collection('static').deleteOne({ docker_img: req.body.search_box }, (deleteErr, deleteResult) => {
              if (deleteErr) {
                console.error(deleteErr);
              } else {
                console.log('이미지 데이터 삭제 완료');
              }
            });

          } else {
            res.render('result_st', { result: result, vulnerabilityData: result.VulnerabilityID });

            // 검색어 db 저장
            db.collection('recent_search').updateOne({ "SearchString": imageName }, { $set: { "createAt": new Date() } }, { upsert: true }, async (err, data3) => {
              if (err) {
                console.error(err);
                res.status(500).json({ error: 'Internal Server Error' });
              } else {
                console.log('recent_search save success');

                let documentCount = await db.collection('recent_search').countDocuments();

                while (documentCount > 10) {
                  const oldestDocument = await db.collection('recent_search').findOne({}, { sort: { createAt: 1 } });
                  if (oldestDocument) {
                    await db.collection('recent_search').deleteOne({ _id: oldestDocument._id });
                    documentCount--;
                    console.log('Oldest Document deleted');
                  }
                }
              }
            });
          }
          return;

        } else {
          setTimeout(() => {
            console.log('데이터 없음');
            console.log(imageName);
            recursivePrintDb(imageName, res, false); // 재귀적으로 호출하여 일정 시간마다 데이터 확인
          }, 10000); // 10초마다 요청
        }
      }
    });
  }
});



//result_st에서 재요청 했을 때
app.get('/result_st', async (req, res) => {
  console.log('이미지명전송');
  const imageName2 = req.query.img_name; // 이미지명 추출
  //값이 req.body.search_box 가 아니라 함수호출 못 함.
  try {
    const result = await db.collection('static').findOne({ docker_img: imageName2 });
    if (result) {
      console.log(result);
      if (result.start_time === 'error') {
        // start_time 필드가 'error'이면 'non_dockerimg'로 render
        res.render('non_dockerimg');
        // 해당 도커 이미지 데이터 삭제
        db.collection('static').deleteOne({ docker_img: req.body.search_box }, (deleteErr, deleteResult) => {
          if (deleteErr) {
            console.error(deleteErr);
          } else {
            console.log('이미지 데이터 삭제 완료');
          }
        });

      } else {
        res.render('result_st', { result: result, vulnerabilityData: result.VulnerabilityID });
      }
    } else {
      res.render('error'); // 데이터가 없을 경우 에러 처리
    }
  } catch (error) {
    console.error(error);
    res.render('error');
  }
});

//result_dy에서 재요청 했을 때
app.get('/result_dy', async (req, res) => {
  console.log('이미지명전송');
  const imageName2 = req.query.img_name; // 이미지명 추출
  //값이 req.body.search_box 가 아니라 함수 호출 못 함.
  try {
    const result = await db.collection('dynamic').findOne({ docker_img: imageName2 });
    if (result) {
      console.log(result);

      res.render('result_dy', { result: result, root_check: result.root_check, netstat_result: result.netstat_result, netstat_dict: result.netstat_dict, netstat_dict_len: result.netstat_dict_len, lsof_detect: result.lsof_detect, lsof_data: result.lsof_data, detected_f: result.detected_f, detected_dict_len: result.detected_dict_len, detected_dict: result.detected_dict }); //성공 시 결과 반환
    } else {
      res.redirect('/non.html'); //데이터 없을 시 알림창 페이지 반환
    }
  } catch (error) {
    console.error(error);
    res.redirect('/non.html');
  }
});

//db 출력 함수
async function printDatabase(req, res) {
  try {
    console.log('호출성공');
    db.collection('static').findOne({ docker_img: req.body.search_box }, (err, result) => {
      if (err) {
        console.error(err);
        res.render('error'); // 에러 발생 시 error.ejs 렌더링
      } else {
        if (result) {
          console.log(result);

          if (result.start_time === 'error') {
            // start_time 필드가 'error'이면 'non_dockerimg'로 render
            res.render('non_dockerimg');

            setTimeout(() => {
              db.collection('static').deleteOne({ docker_img: req.body.search_box }, (deleteErr, deleteResult) => {
                if (deleteErr) {
                  console.error(deleteErr);
                } else {
                  console.log('이미지 데이터 삭제 완료');
                }
              });
            }, 1000); // 1000ms(1초) 후에 실행
            // 해당 도커 이미지 데이터 삭제

          } else {
            res.render('result_st', { result: result, vulnerabilityData: result.VulnerabilityID });
          }

          return;
        } // result.ejs 렌더링 시 result 데이터 전달
        else {
          setTimeout(() => {
            printDatabase(req, res);
          }, 5000);
        }
      }
    });
  } catch (error) {
    console.error(error);
  }
}

const bucket = new GridFSBucket(db, { bucketName: 'fs' });

app.get('/download', async (req, res) => {
  // const imageName = req.query.img_name+'_result.pdf'; // 형식지정
  if (req.query.img_name) { //이미명 넘겨주면
    const imageName = req.query.img_name;

    if (imageName.includes('/')) { //이미지명에 /가 있으면
      const imageParts = imageName.split('/'); //  '/'기준으로 분할

      const imageNamePart1 = imageParts[0];
      const imageNamePart2 = imageParts[1];
      const imgname = imageNamePart1 + "_" + imageNamePart2 + "_result.pdf" //형식 지정

      console.log(imageNamePart1); // 첫 번째 부분 출력
      console.log(imageNamePart2); // 두 번째 부분 출력
      download_img(imgname, res);
    }
    else {
      const imgname = req.query.img_name + '_result.pdf'; // '/'없으면 바로 형식지정
      console.log(imgname);
      download_img(imgname, res);
    }

  } else { //파일명 넘겨주면
    const imgname = req.query.file; //guide.pdf 다운
    console.log(imgname);
    download_img(imgname, res);
  }
});

app.get('/recent-search', async (req, res) => {
  try {
    // recent_search collection에서 최근 검색어를 가져옵니다.
    const recentSearches = await db.collection('recent_search').find().sort({ createAt: -1 }).toArray();
    const searchStrings = recentSearches.map(item => item.SearchString);

    // 최근 검색어 목록을 JSON 형식으로 응답합니다.
    res.json(searchStrings);
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'Internal Server Error' });
  }
});


//파일 다운 함수
async function download_img(imgname, res) {
  try {
    const file = await db.collection('fs.files').findOne({ filename: imgname });
    console.log(imgname);

    if (!file) {
      return res.status(404).json({ error: 'File not found.' });
    }

    const downloadStream = bucket.openDownloadStream(file._id);
    res.set('Content-Disposition', `attachment; filename="${file.filename}"`);
    res.set('Content-Type', 'application/octet-stream');
    downloadStream.pipe(res);
  } catch (err) {
    console.error(err);
    return res.status(500).json({ error: 'Internal Server Error' });
  }
}

app.use('/users', usersRouter);

// catch 404 and forward to error handler
app.use(function (req, res, next) {

  next(createError(404));
});

// error handler
app.use(function (err, req, res, next) {
  // set locals, only providing error in development
  res.locals.message = err.message;
  res.locals.error = req.app.get('env') === 'development' ? err : {};

  // render the error page
  res.status(err.status || 500);
  res.render('error');
});



module.exports = app;

var server = app.listen(app.get('port'), function () {

  console.log('Express server listening on port ' + server.address().port);

});
